---
layout:     post
title:      "同步容器与并发容器(六):Deque"
subtitle:   "Deque"
date:       2017-12-28 12:00:00
author:     "zfl"
header-img: "img/vitruvian.jpg"
header-mask: 0.6
catalog:    true
tags:
    - java
    - 并发
    - deque 
    - 容器
--- 
> java 6 增加了两种容器类型，Deque和BlockingDeque，分别对Queue和BlockingQueue进行了扩展。数据结构上是**双端队列**，可以在队头和队尾进行高效的移除和插入操作。由于之前已经在Queue介绍了阻塞队列以及非阻塞的ConcurrentLinkedQueue，双端队列有着同样的实现，因此不会过多的描述，只会关注使用双端队列适用于的一种算法模式--工作密取。

### 工作密取   

在生产者--消费者模式中，所有的消费者有一个共享的工作队列，而在工作密取（Work Stealing）设计中，每个消费者都有自己的双端队列。如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者的双端队列末尾秘密的获取工作。相对比喻传统的生产者--消费者模式有着更高的**可伸缩性**，因为工作者线程不会再单个共享的任务队列上发生竞争。大多数时候，他们都只访问自己的双端队列，从而极大的减少了竞争。当工作线程需要访问另一个队列时，它会从队列的尾部而不是头部获取工作，因此进一步降低了队列上的竞争程度。另一方面，确保每个线程都保持忙碌状态。  

**试用场景**：工作线程**既是消费者也是生产者**的问题，当执行某个工作时可能会导致更多的工作。比如：
1. 图的遍历。
**广搜**：从一个节点出发，当到达一个节点时，将该节点的连接节点加入到队列末尾，然后再出队操作。**深搜**：使用栈，当到达一个节点时，将该节点的连接节点入栈，然后进行出栈操作。
如果使用工作密取模式，则可以有多个工作线程，从不同的节点开始遍历，每个线程都有一个双端队列，到达一个节点时将该节点入队到该线程对应的双端队列（广搜加入尾部，深搜加入头部），当一个工作线程中为空，则可以到其他双端队列末尾获取图的节点继续遍历。
2. 网页爬虫。当处理一个页面时，通常会发现有更多的页面需要处理。
3. 垃圾回收阶段对堆进行标记。主要用于垃圾回收算法（标记-清除、标记-压缩）中的标记阶段。首先找到**根对象**，从根对象开始遍历，每一个可以到达的对象都进行标记。 java7提供了**ForkJoinPool**，其中就用到了工作窃取模式算法。
  





